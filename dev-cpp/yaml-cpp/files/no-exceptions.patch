diff --git a/include/yaml-cpp/node/detail/impl.h b/include/yaml-cpp/node/detail/impl.h
index b38038d..63cac78 100644
--- a/include/yaml-cpp/node/detail/impl.h
+++ b/include/yaml-cpp/node/detail/impl.h
@@ -14,6 +14,7 @@
 #include <type_traits>
 
 namespace YAML {
+[[noreturn]] void throw_bad_subscript(const YAML::Mark& mark);
 namespace detail {
 template <typename Key, typename Enable = void>
 struct get_idx {
@@ -128,7 +129,7 @@ inline node* node_data::get(const Key& key,
         return pNode;
       return nullptr;
     case NodeType::Scalar:
-      throw BadSubscript(m_mark, key);
+      throw_bad_subscript(m_mark);
   }
 
   auto it = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
@@ -154,7 +155,7 @@ inline node& node_data::get(const Key& key, shared_memory_holder pMemory) {
       convert_to_map(pMemory);
       break;
     case NodeType::Scalar:
-      throw BadSubscript(m_mark, key);
+      throw_bad_subscript(m_mark);
   }
 
   auto it = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
@@ -200,6 +201,8 @@ inline bool node_data::remove(const Key& key, shared_memory_holder pMemory) {
   return false;
 }
 
+[[nodiscard]] void throw_bad_insert();
+
 // map
 template <typename Key, typename Value>
 inline void node_data::force_insert(const Key& key, const Value& value,
@@ -213,7 +216,7 @@ inline void node_data::force_insert(const Key& key, const Value& value,
       convert_to_map(pMemory);
       break;
     case NodeType::Scalar:
-      throw BadInsert();
+      throw_bad_insert();
   }
 
   node& k = convert_to_node(key, pMemory);
diff --git a/include/yaml-cpp/node/impl.h b/include/yaml-cpp/node/impl.h
index 312281f..110262d 100644
--- a/include/yaml-cpp/node/impl.h
+++ b/include/yaml-cpp/node/impl.h
@@ -16,6 +16,8 @@
 #include <string>
 
 namespace YAML {
+[[noreturn]] extern void throw_invalid_node(const std::string& key);
+[[noreturn]] extern void throw_bad_conversion(const YAML::Mark& mark);
 inline Node::Node()
     : m_isValid(true), m_invalidKey{}, m_pMemory(nullptr), m_pNode(nullptr) {}
 
@@ -57,7 +59,7 @@ inline Node::~Node() = default;
 
 inline void Node::EnsureNodeExists() const {
   if (!m_isValid)
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   if (!m_pNode) {
     m_pMemory.reset(new detail::memory_holder);
     m_pNode = &m_pMemory->create_node();
@@ -74,14 +76,14 @@ inline bool Node::IsDefined() const {
 
 inline Mark Node::Mark() const {
   if (!m_isValid) {
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   }
   return m_pNode ? m_pNode->mark() : Mark::null_mark();
 }
 
 inline NodeType::value Node::Type() const {
   if (!m_isValid)
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   return m_pNode ? m_pNode->type() : NodeType::Null;
 }
 
@@ -125,12 +127,12 @@ struct as_if<T, void> {
 
   T operator()() const {
     if (!node.m_pNode)
-      throw TypedBadConversion<T>(node.Mark());
+      throw_bad_conversion(node.Mark()); // <T>
 
     T t;
     if (convert<T>::decode(node, t))
       return t;
-    throw TypedBadConversion<T>(node.Mark());
+    throw_bad_conversion(node.Mark()); // <T>
   }
 };
 
@@ -143,7 +145,7 @@ struct as_if<std::string, void> {
     if (node.Type() == NodeType::Null)
       return "null";
     if (node.Type() != NodeType::Scalar)
-      throw TypedBadConversion<std::string>(node.Mark());
+      throw_bad_conversion(node.Mark()); // <std::string>
     return node.Scalar();
   }
 };
@@ -152,7 +154,7 @@ struct as_if<std::string, void> {
 template <typename T>
 inline T Node::as() const {
   if (!m_isValid)
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   return as_if<T, void>(*this)();
 }
 
@@ -165,13 +167,13 @@ inline T Node::as(const S& fallback) const {
 
 inline const std::string& Node::Scalar() const {
   if (!m_isValid)
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   return m_pNode ? m_pNode->scalar() : detail::node_data::empty_scalar();
 }
 
 inline const std::string& Node::Tag() const {
   if (!m_isValid)
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   return m_pNode ? m_pNode->tag() : detail::node_data::empty_scalar();
 }
 
@@ -182,7 +184,7 @@ inline void Node::SetTag(const std::string& tag) {
 
 inline EmitterStyle::value Node::Style() const {
   if (!m_isValid)
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   return m_pNode ? m_pNode->style() : EmitterStyle::Default;
 }
 
@@ -194,7 +196,7 @@ inline void Node::SetStyle(EmitterStyle::value style) {
 // assignment
 inline bool Node::is(const Node& rhs) const {
   if (!m_isValid || !rhs.m_isValid)
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   if (!m_pNode || !rhs.m_pNode)
     return false;
   return m_pNode->is(*rhs.m_pNode);
@@ -215,7 +217,7 @@ inline Node& Node::operator=(const Node& rhs) {
 
 inline void Node::reset(const YAML::Node& rhs) {
   if (!m_isValid || !rhs.m_isValid)
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   m_pMemory = rhs.m_pMemory;
   m_pNode = rhs.m_pNode;
 }
@@ -223,7 +225,7 @@ inline void Node::reset(const YAML::Node& rhs) {
 template <typename T>
 inline void Node::Assign(const T& rhs) {
   if (!m_isValid)
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   AssignData(convert<T>::encode(rhs));
 }
 
@@ -253,7 +255,7 @@ inline void Node::AssignData(const Node& rhs) {
 
 inline void Node::AssignNode(const Node& rhs) {
   if (!m_isValid)
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   rhs.EnsureNodeExists();
 
   if (!m_pNode) {
@@ -270,7 +272,7 @@ inline void Node::AssignNode(const Node& rhs) {
 // size/iterator
 inline std::size_t Node::size() const {
   if (!m_isValid)
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   return m_pNode ? m_pNode->size() : 0;
 }
 
@@ -303,7 +305,7 @@ inline iterator Node::end() {
 template <typename T>
 inline void Node::push_back(const T& rhs) {
   if (!m_isValid)
-    throw InvalidNode(m_invalidKey);
+    throw_invalid_node(m_invalidKey);
   push_back(Node(rhs));
 }
 
diff --git a/src/exceptions.cpp b/src/exceptions.cpp
index 43a7976..da7f960 100644
--- a/src/exceptions.cpp
+++ b/src/exceptions.cpp
@@ -17,4 +17,24 @@ BadPushback::~BadPushback() YAML_CPP_NOEXCEPT = default;
 BadInsert::~BadInsert() YAML_CPP_NOEXCEPT = default;
 EmitterException::~EmitterException() YAML_CPP_NOEXCEPT = default;
 BadFile::~BadFile() YAML_CPP_NOEXCEPT = default;
+
+[[noreturn]] void throw_bad_subscript(const YAML::Mark& mark)
+{
+	throw BadSubscript(mark, std::string{});
+}
+
+[[noreturn]] void throw_invalid_node(const std::string& key)
+{
+	throw InvalidNode(key);
+}
+
+[[noreturn]] void throw_bad_conversion(const YAML::Mark& mark)
+{
+	throw BadConversion(mark);
+}
+
+[[noreturn]] void throw_bad_insert()
+{
+	throw BadInsert();
+}
 }  // namespace YAML
